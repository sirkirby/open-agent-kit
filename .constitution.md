# open-agent-kit Constitution

## Metadata

- **Project:** open-agent-kit
- **Version:** 3.0.0
- **Status:** Adopted
- **Last Updated:** 2025-11-28
- **Author:** @sirkirby
- **Tech Stack:** Python 3.13+, Typer, Pydantic, Rich, Jinja2

**Description:** Open Agent Kit (OAK) is a CLI tool for AI-powered development workflows. It provides agent-agnostic command templates and cli tools to assist and enhance building with AI agents.

This document serves as the central reference for how open-agent-kit is designed, built, and maintained. All agent instruction files reference this constitution.

---

## I. Core Principles

### 1.1 Simplicity First
- Keep the CLI intuitive and easy to use
- Minimize configuration requirements
- Provide sensible defaults
- Make common tasks simple, complex tasks possible

### 1.2 Local-First Design
- No mandatory external dependencies
- Git optional but supported
- Works offline

### 1.3 AI-Assisted Productivity
- Integrate with multiple AI agents
- Templates designed for AI enhancement
- Commands support AI workflows
- Agent-agnostic architecture

### 1.4 Cross-Platform Compatibility
- Support Unix/Linux, macOS, and Windows
- Provide both bash and PowerShell scripts, though CLI commands preferred
- Test on multiple platforms
- Use platform-agnostic Python core

### 1.5 Template-Driven
- All content generated from templates
- Templates are managed by oak (overwritten on upgrade)
- Use Jinja2 for rendering
- Support template inheritance

---

## II. Project Structure

### 2.1 Directory Layout

```bash
open-agent-kit/
├── src/open_agent_kit/               # Source code
│   ├── cli.py             # Main CLI entry point
│   ├── constants.py       # Configuration constants
│   ├── commands/          # CLI command implementations
│   │   ├── init_cmd.py   # oak init
│   │   ├── rfc_cmd.py    # oak rfc commands
│   │   └── feature_cmd.py # oak feature commands
│   ├── models/            # Data models (Pydantic)
│   │   ├── agent.py      # Agent configuration
│   │   ├── config.py     # Configuration models
│   │   ├── feature.py    # Feature manifest model
│   │   └── rfc.py        # RFC document models
│   ├── services/          # Business logic
│   │   ├── agent_service.py
│   │   ├── config_service.py
│   │   ├── feature_service.py
│   │   ├── rfc_service.py
│   │   └── template_service.py
│   └── utils/             # Utility functions
│       ├── console.py
│       ├── file_utils.py
│       ├── interactive.py
│       ├── step_tracker.py
│       └── validation.py
├── features/              # Feature packages
│   ├── core/             # Core assets (IDE settings)
│   │   ├── manifest.yaml
│   │   └── ide/
│   ├── constitution/     # Constitution feature
│   │   ├── manifest.yaml
│   │   ├── commands/     # Agent command templates
│   │   └── templates/    # Document templates
│   ├── rfc/              # RFC feature
│   │   ├── manifest.yaml
│   │   ├── commands/
│   │   └── templates/
│   └── issues/           # Issues feature
│       ├── manifest.yaml
│       └── commands/
├── tests/                # Test suite
├── docs/                 # Documentation
├── .github/              # GitHub configuration
│   └── workflows/       # CI/CD workflows
└── pyproject.toml       # Project configuration
```

### 2.2 User Project Structure

After `oak init`, user projects have:

```bash
project/
├── .oak/                     # Configuration directory
│   ├── config.yaml            # Project configuration (includes features.enabled)
│   └── features/             # Feature-specific assets
│       ├── constitution/
│       │   └── templates/    # Constitution templates
│       ├── rfc/
│       │   └── templates/    # RFC templates
│       └── issues/
│           └── templates/    # Issue templates
├── oak/                      # Generated artifacts
│   ├── constitution.md        # Project constitution
│   ├── rfc/                  # RFC documents
│   │   └── RFC-*.md
│   └── issues/                # Issue specifications (spec-driven development)
│       └── {provider}/
│           └── {issue}/
│               ├── context.json
│               └── plan.md
└── .{agent}/commands/        # Agent-specific command files
```

### 2.3 Configuration Hierarchy

1. **Built-in defaults** - In `src/open_agent_kit/constants.py`
2. **Project config** - In `.oak/config.yaml`
3. **Environment variables** - For API keys, etc.
4. **Command-line arguments** - Highest priority

`.oak/` is reserved for installation assets (templates, commands, config). All generated work products (RFCs, constitutions, issue specs) live under `oak/` so they can be version-controlled safely.

---

## III. Architecture Patterns

### 3.1 Layered Architecture

```
┌─────────────────────────┐
│   CLI Layer (Typer)     │  ← User interaction
├─────────────────────────┤
│   Command Layer         │  ← Command implementations
├─────────────────────────┤
│   Service Layer         │  ← Business logic
├─────────────────────────┤
│   Model Layer (Pydantic)│  ← Data structures
├─────────────────────────┤
│   Storage Layer         │  ← File system, YAML
└─────────────────────────┘
```

### 3.2 Design Patterns

- **Service Layer Pattern**: Business logic separated from CLI
- **Repository Pattern**: Configuration and data access abstracted
- **Template Method Pattern**: Template rendering with hooks
- **Strategy Pattern**: Multiple agent implementations
- **Factory Pattern**: Agent and template creation

### 3.3 Error Handling

```python
try:
    # Attempt operation
    result = service.operation()
except SpecificError as e:
    # User-friendly error message
    console.error(f"Failed to complete operation: {e}")
    # Provide helpful guidance
    console.info("Try: oak --help")
    sys.exit(1)
```

---

## IV. Code Standards

### 4.1 Python Style

- **PEP 8 compliance**: Use ruff for linting
- **Type hints**: All function signatures must have types
- **Docstrings**: Google-style for all public functions
- **Line length**: 100 characters maximum
- **Formatting**: Use black for consistent formatting

### 4.2 Type Hints

```python
from typing import Optional, List
from pathlib import Path

def create_rfc(
    title: str,
    author: str,
    template: str = "engineering",
    tags: Optional[List[str]] = None
) -> RFCDocument:
    """Create a new RFC document."""
    pass
```

### 4.3 Docstrings

```python
def validate_rfc(file_path: Path, strict: bool = False) -> ValidationResult:
    """Validate an RFC document.

    Args:
        file_path: Path to the RFC file
        strict: Use strict validation rules

    Returns:
        ValidationResult with issues found

    Raises:
        FileNotFoundError: If RFC file doesn't exist
        ValidationError: If RFC format is invalid
    """
    pass
```

### 4.4 Constants and Magic Strings

**Never use magic strings or numbers.** All literal values should be defined as constants in `src/open_agent_kit/constants.py`.

**Bad - Magic Strings:**
```python
if agent_type == "claude":  # Magic string
    folder = ".claude/"  # Magic string
    
if status == "approved":  # Magic string
    process_rfc()
    
path = Path(".oak/config.yaml")  # Magic string
```

**Good - Using Constants:**
```python
from open_agent_kit.constants import (
    AGENT_CONFIG,
    RFC_STATUSES,
    CONFIG_FILE,
)

if agent_type in AGENT_CONFIG:
    folder = AGENT_CONFIG[agent_type]["folder"]
    
if status == RFC_STATUSES[2]:  # Or use named constant
    process_rfc()
    
path = Path(CONFIG_FILE)
```

**When to Create Constants:**
- File paths and directory names
- Configuration keys and values
- Status values and enums
- Error messages and success messages
- Template names and formats
- Regular expression patterns
- Color codes and styling
- Any repeated literal value (used 2+ times)

**Constants Organization:**
```python
# In src/open_agent_kit/constants.py

# Directory structure
OAK_DIR = ".oak"
RFC_DIR = "oak/rfc"
CONFIG_FILE = ".oak/config.yaml"

# Status values
RFC_STATUSES = ["draft", "review", "approved", "adopted"]

# Messages (for consistency and i18n readiness)
SUCCESS_MESSAGES = {
    "init": "Successfully initialized open-agent-kit!",
    "rfc_created": "RFC created successfully!",
}

ERROR_MESSAGES = {
    "no_oak_dir": "No .oak directory found. Run 'oak init' first.",
    "invalid_rfc_number": "Invalid RFC number format.",
}

# Colors (centralized styling)
COLORS = {
    "primary": "cyan",
    "success": "green",
    "error": "red",
}
```

### 4.5 Error Messages

- Be specific about what went wrong
- Provide actionable guidance
- Use consistent formatting from `ERROR_MESSAGES` constant
- No emojis unless user explicitly requests them

**Good:**
```python
from open_agent_kit.constants import ERROR_MESSAGES

console.error(ERROR_MESSAGES["rfc_not_found"])
console.info("Try: oak rfc list")
```

**Bad:**
```python
console.error("File not found")  # Vague, inconsistent
```

---

## V. CLI Design

### 5.1 Command Structure

```bash
oak [OPTIONS] COMMAND [ARGS]

Commands:
  init        Initialize .oak directory
  rfc         RFC management commands
  version     Show version information
```

### 5.2 Subcommand Pattern

```bash
oak rfc [OPTIONS] SUBCOMMAND [ARGS]

Subcommands:
  create      Create new RFC
  list        List all RFCs
  validate    Validate RFC format
  show        Show RFC details
```

### 5.3 Command usage

User facing commands for oak installation management and configuration:

```bash
# Examples:
oak init [--agent AGENT]
oak upgrade [--dry-run
oak config
```

Agent facing commands referenced in command prompt templates:

```bash
# Examples:
oak rfc create|list|validate
oak constitution create-file|validate|amend
oak issue plan|validate|implement
```

### 5.4 Option Conventions

- Short flags: `-a`, `-v`, `-f`
- Long flags: `--agent`, `--verbose`, `--force`
- Required arguments: `<description>`
- Optional arguments: `[file]`
- Boolean flags: `--no-interactive`, `--force`

### 5.5 Output Design

- Use Rich for formatted output
- Progress indicators for long operations
- Tables for list views
- Panels for detailed information
- Colors for status (green=success, red=error, yellow=warning, blue=info)

### 5.6 Issue Provider Commands (Summary)

- Agents must never run `oak config`; humans handle provider setup interactively.
- Before executing any `oak issue ...` command, verify (in order): constitution exists,
  provider configured, issue ID provided.
- `oak issue plan` scaffolds artifacts, `issue validate` inspects them, and `issue implement`
  prepares the branch for coding—each requires the previous step's outputs.
- Detailed workflows, artifact descriptions, and troubleshooting live in `docs/issue-workflow.md`.

---

## VI. Features System

### 6.1 Feature Architecture

Open Agent Kit uses a modular feature system. Each feature is a self-contained package:

| Feature | Description | Dependencies |
|---------|-------------|--------------|
| **constitution** | Engineering standards, architectural patterns, team conventions | None |
| **rfc** | RFC workflow for documenting technical decisions | constitution |
| **issues** | Issue workflow integration with Azure DevOps/GitHub Issues | constitution |

Core assets (IDE settings) live in `features/core/` and are always installed.

### 6.2 Feature Manifest

Each feature has a `manifest.yaml`:

```yaml
name: my-feature
display_name: "My Feature"
description: "What this feature does"
version: "1.0.0"
default_enabled: true
dependencies: []               # Required features
commands: []                   # Command names (without extension)
templates: []                  # Template paths
config_defaults: {}            # Default config values
```

### 6.3 Dependency Resolution

Features can depend on other features. The `FeatureService` handles:
- Automatic dependency inclusion when installing
- Dependency checking when removing
- Topological sorting for installation order
- Circular dependency detection

### 6.4 Feature CLI Commands

```bash
oak feature              # Interactive feature management
oak feature list         # List installed and available features
oak feature add <name>   # Add a feature (with dependencies)
oak feature remove <name> # Remove a feature (with dependency check)
```

### 6.5 Adding New Features

See `docs/development/features.md` for the complete playbook. Key steps:
1. Create `features/<name>/manifest.yaml`
2. Add command templates in `features/<name>/commands/`
3. Add document templates in `features/<name>/templates/`
4. Update constants (`SUPPORTED_FEATURES`, `FEATURE_CONFIG`)
5. Write tests
6. Update documentation

---

## VII. Template System

### 7.1 Template Type examples

1. **Command Templates** - For AI agent commands (in `features/<feature>/commands/`)
   - `oak.rfc-create.md` - RFC creation assistant
   - `oak.rfc-validate.md` - RFC validation assistant

2. **Document Templates** - For generated documents (in `features/<feature>/templates/`)
   - `engineering.md.j2` - Full technical RFC
   - `constitution.md.j2` - Project constitution

### 7.2 Template Variables

Example use of variables in templates:

```jinja
{{ rfc_number }}       # RFC number (e.g., "001")
{{ title }}            # RFC title
{{ author }}           # Author name
{{ date }}             # Current date (YYYY-MM-DD)
{{ description }}      # RFC description
{{ project_name }}     # Project name
```

---

## VIII. Testing Strategy

### 8.1 Test Types

1. **Unit Tests** - Test individual functions
2. **Integration Tests** - Test command workflows
3. **E2E Tests** - Test full user workflows
4. **Platform Tests** - Test on Ubuntu, Windows, macOS

### 8.2 Test Structure

```bash
tests/
├── unit/
│   ├── test_models.py
│   ├── test_services.py
│   └── test_utils.py
├── integration/
│   ├── test_cli.py
│   └── test_workflows.py
└── conftest.py
```

### 8.3 Coverage Requirements

- Minimum 80% code coverage
- All public APIs tested
- Critical paths fully covered
- Error cases tested

---

## IX. Release Process

### 9.1 Version Numbering

Follow Semantic Versioning (semver):

- **MAJOR.MINOR.PATCH** (e.g., 1.2.3)
- **Pre-releases**: `-beta.1`, `-rc.1`, `-alpha.1`

Increment:
- **MAJOR**: Breaking changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes

### 9.2 Release Checklist

- [ ] Update version in `pyproject.toml`
- [ ] Update version in `src/__init__.py`
- [ ] Update CHANGELOG (if maintained)
- [ ] Run full test suite
- [ ] Run linting and formatting
- [ ] Create git tag
- [ ] Push tag to trigger release workflow

### 9.3 Release Artifacts

Each release includes:
- Python wheel (.whl)
- Source distribution (.tar.gz)
- 12 template packages (6 agents × 2 script types)

---

## X. AI Agent Integration

### 10.1 Supported Agents

| Agent | Description | Instruction File | Command Directory |
|-------|-------------|------------------|-------------------|
| **Claude Code** | Anthropic's AI assistant | `.claude/CLAUDE.md` | `.claude/commands/` |
| **GitHub Copilot** | Microsoft's pair programmer | `.github/copilot-instructions.md` | `.github/agents/` |
| **Codex CLI** | OpenAI's code generation | `AGENTS.md` | `.codex/prompts/` |
| **Cursor** | AI-powered editor | `AGENTS.md` | `.cursor/commands/` |
| **Gemini CLI** | Google's Gemini assistant | `GEMINI.md` | `.gemini/commands/` |
| **Windsurf** | Codeium's AI editor | `.windsurf/rules/rules.md` | `.windsurf/commands/` |

### 10.2 Agent Command Structure

Agent commands are markdown files that guide the AI:

```markdown
# Command Name

Brief description of what this command does.

## Instructions

1. Step 1
2. Step 2
3. Step 3

## Examples

...
```

### 10.3 Adding New Agent Support

To add a new agent:

1. **Add to SUPPORTED_AGENTS** in `constants.py`:
   ```python
   SUPPORTED_AGENTS = ["claude", "copilot", "codex", "cursor", "gemini", "windsurf", "new_agent", "none"]
   ```

2. **Add agent config** to `AGENT_CONFIG` in `constants.py`:
   ```python
   "new_agent": {
       "name": "New Agent",
       "folder": ".new_agent/",
       "commands_subfolder": "commands",
       "file_extension": ".md",
       "requires_cli": False,
       "install_url": None,
   },
   ```

3. **Add instruction file pattern** to `AGENT_INSTRUCTION_PATTERNS` in `constants.py`

4. **Update AgentService** to handle the new agent's command installation

5. **Update documentation** (README, QUICKSTART)

---

## XI. Contributing Guidelines

### 11.1 Code Contributions

1. **Fork repository**
2. **Create feature branch**: `feature/description`
3. **Make changes** with tests
4. **Run checks locally**:
   ```bash
   make check
   make test
   ```
5. **Create pull request**
6. **Address review feedback**
7. **Merge when approved**

### 11.2 Commit Messages

Use conventional commits:

- `Add:` New features
- `Fix:` Bug fixes
- `Update:` Modifications to existing features
- `Docs:` Documentation changes
- `Test:` Test additions/changes
- `Refactor:` Code refactoring

### 11.3 PR Requirements

- All tests pass
- Code coverage maintained
- Documentation updated
- No linting errors
- Type checking passes
- **No magic strings or numbers** (use constants)

---

## XI-A. Constants Best Practices

### XI-A.1 The Constants-First Principle

**All literal values must be defined as constants.** This is a core principle of open-agent-kit development.

### XI-A.2 When to Create a Constant

Create a constant for:
- **File paths and directory names** (`.oak`, `config.yaml`, etc.)
- **Configuration keys** (`agents`, `version`, `rfc`, etc.)
- **Status values** (`draft`, `approved`, `implemented`)
- **Error and success messages** (for consistency and future i18n)
- **Template names** (`engineering`, `architecture`, etc.)
- **Regular expressions** (RFC patterns, validation patterns)
- **Color codes and styles** (`cyan`, `green`, `red`)
- **Any literal used 2+ times** in the codebase
- **Magic numbers** (timeouts, limits, defaults)

### XI-A.3 Constants Location

**All constants live in:** `src/open_agent_kit/constants.py`

**Organization within constants.py:**
```python
# Version information
VERSION = __version__

# Directory structure
OAK_DIR = ".oak"
RFC_DIR = "oak/rfc"
CONFIG_FILE = ".oak/config.yaml"

# Agent configurations
SUPPORTED_AGENTS = ["claude", "copilot", "codex", "cursor"]
AGENT_CONFIG = {
    "claude": {
        "name": "Claude Code",
        "folder": ".claude/",
        # ...
    },
}

# RFC configuration
RFC_STATUSES = ["draft", "review", "approved", "adopted"]
RFC_TEMPLATES = {
    "engineering": "Engineering RFC Template",
    "architecture": "Architecture Decision Record",
}

# Messages (consistency + i18n ready)
SUCCESS_MESSAGES = {
    "init": "Successfully initialized open-agent-kit!",
    "rfc_created": "RFC created successfully!",
}

ERROR_MESSAGES = {
    "no_oak_dir": "No .oak directory found. Run 'oak init' first.",
    "invalid_rfc_number": "Invalid RFC number format.",
}

# UI/Styling
COLORS = {
    "primary": "cyan",
    "success": "green",
    "error": "red",
}

PROGRESS_CHARS = {
    "complete": "✓",
    "incomplete": "○",
    "error": "✗",
}
```

### XI-A.4 Using Constants

**Import at module level:**
```python
from open_agent_kit.constants import (
    OAK_DIR,
    CONFIG_FILE,
    RFC_STATUSES,
    SUCCESS_MESSAGES,
    ERROR_MESSAGES,
    COLORS,
)
```

**Use throughout code:**
```python
# File operations
config_path = project_root / CONFIG_FILE
oak_dir = project_root / OAK_DIR

# Status checks
if rfc.status in RFC_STATUSES:
    process_rfc(rfc)

# User messages
console.print(f"[{COLORS['success']}]{SUCCESS_MESSAGES['init']}[/]")
console.error(ERROR_MESSAGES["no_oak_dir"])

# Configuration
if agent_type in AGENT_CONFIG:
    folder = AGENT_CONFIG[agent_type]["folder"]
```

### XI-A.5 Benefits of Constants

1. **Single Source of Truth** - Change once, affects everywhere
2. **Type Safety** - Catch typos at import time
3. **IDE Support** - Autocomplete and refactoring
4. **Consistency** - Same values everywhere
5. **Maintainability** - Easy to update
6. **Testability** - Easy to mock/override
7. **i18n Ready** - Messages centralized for translation
8. **Documentation** - Constants file serves as reference

### XI-A.6 Anti-Pattern Examples

**❌ Bad - Magic Strings:**
```python
# Scattered throughout codebase
if agent == "claude":
    path = Path(".claude/commands")
    
console.print("[green]Success![/green]")
config = yaml.load(Path(".oak/config.yaml"))

if status == "approved":
    process()
```

**✅ Good - Using Constants:**
```python
from open_agent_kit.constants import (
    AGENT_CONFIG,
    COLORS,
    CONFIG_FILE,
    RFC_STATUSES,
)

if agent in AGENT_CONFIG:
    path = Path(AGENT_CONFIG[agent]["folder"]) / AGENT_CONFIG[agent]["commands_subfolder"]
    
console.print(f"[{COLORS['success']}]Success![/]")
config = yaml.load(Path(CONFIG_FILE))

# Use index or create named constant
RFC_STATUS_APPROVED = RFC_STATUSES[2]
if status == RFC_STATUS_APPROVED:
    process()
```

### XI-A.7 Adding New Constants

When adding a new constant:

1. **Add to `constants.py`** in the appropriate section
2. **Use descriptive UPPER_SNAKE_CASE** naming
3. **Add inline comment** if purpose isn't obvious
4. **Group related constants** together
5. **Update this constitution** if it's a new category
6. **Update agent instruction files** with examples

### XI-A.8 Constant Naming Conventions

```python
# Singular for single values
OAK_DIR = ".oak"
CONFIG_FILE = "config.yaml"
DEFAULT_TEMPLATE = "engineering"

# Plural for collections
RFC_STATUSES = [...]
SUPPORTED_AGENTS = [...]
ERROR_MESSAGES = {...}

# Descriptive prefixes for clarity
RFC_DIR = "oak/rfc"
RFC_FILE_EXTENSION = ".md"
RFC_NUMBER_PATTERN = r"^RFC-\d{3}$"

# ALL_CAPS for true constants
MAX_RFC_NUMBER = 9999
DEFAULT_TIMEOUT = 30

# UPPER_SNAKE_CASE for configuration
AGENT_CONFIG = {...}
SUCCESS_MESSAGES = {...}
```

---

## XII. Workflow Automation

### 12.1 PR Validation

Automatic checks on every PR:
- Linting (ruff)
- Formatting (black)
- Type checking (mypy)
- Tests (pytest) - multi-OS, multi-Python
- Template validation (markdownlint)
- Script validation (shellcheck, PSScriptAnalyzer)
- Integration tests

### 12.2 Release Automation

Triggered by version tags:
- Validates version consistency
- Builds Python packages
- Creates template packages
- Runs full test suite
- Creates GitHub release
- Uploads all artifacts

---

## XIII. Security Practices

### 13.1 Dependencies

- Pin major versions only
- Regular dependency updates
- Security scanning (if available)
- No known vulnerabilities

### 13.2 Secrets Management

- Never commit API keys
- Use environment variables
- Document required secrets
- Support multiple secret sources

### 13.3 Input Validation

- Validate all user inputs
- Sanitize file paths
- Prevent injection attacks
- Handle edge cases

---

## XIV. Documentation Standards

### 14.1 README Requirements

Every significant directory should have a README:

```markdown
# Directory Name

Brief description.

## Contents

- File 1: Description
- File 2: Description

## Usage

Examples...
```

### 14.2 Code Documentation

- All public functions have docstrings
- Complex logic has inline comments
- Type hints on all functions
- Examples in docstrings

### 14.3 User Documentation

Located in `docs/`:
- Getting started guides
- Command references
- Architecture docs
- Development guides

---

## XV. Performance Guidelines

### 15.1 Startup Time

- CLI should start in < 500ms
- Lazy import heavy dependencies
- Cache when appropriate

### 15.2 Operation Speed

- RFC creation: < 1 second
- RFC listing: < 2 seconds
- RFC validation: < 1 second

### 15.3 Resource Usage

- Memory: < 100 MB typical
- Disk: < 10 MB templates
- Network: None required

---

## XVI. Maintenance

### 16.1 Regular Tasks

- Weekly: Review open issues
- Monthly: Update dependencies
- Quarterly: Review architecture
- Yearly: Major version planning

### 16.2 Deprecation Policy

- Announce deprecations 1 minor version ahead
- Maintain backward compatibility for 2 minor versions
- Document migration paths
- Provide warnings in deprecated features

### 16.3 Support

- Issue tracking on GitHub
- Documentation in repository
- Team support channels

---

## XVII-A. Feature Delivery Playbook

The exhaustive checklist for adding or extending features now lives in
`docs/development/features.md`. Use that playbook for step-by-step guidance. This
constitution keeps the high-level rules:

- Always update `AgentService.create_default_commands()` and
  `UpgradeService._get_upgradeable_commands()` when new agent commands are introduced.
- Keep all literals in `src/open_agent_kit/constants.py`.
- Ensure every CLI utility command supports `--json` for agent consumption.
- Tests, documentation, and templates must be updated alongside code.

## XVII-B. Migration System for Upgrade Tasks

The full migration playbook now lives in `docs/development/migrations.md`. Key takeaways:

- Migrations run once via `oak upgrade` and are tracked in `.oak/config.yaml`.
- Create one when you must mutate user files/directories or backfill data—*not* for normal
  template or command updates.
- IDs follow `YYYY.MM.DD_name`. Append new migrations to
  `open_agent_kit/services/migrations.py::get_migrations()`.
- Keep every migration idempotent, well-documented, and covered by tests across fresh and
  existing projects.

## XVIII. Amendment Process

This constitution can be amended when needed:

1. **Propose change** - Create issue or PR
2. **Discuss with team** - Review and gather feedback
3. **Update document** - Increment version
4. **Update agent files** - Ensure consistency
5. **Announce changes** - Notify team

**Version History:**
- v3.0.0 (2025-11-28) - Added features system (Section VI); reorganized templates/ to features/ directory; added FeatureService and feature CLI commands; updated section numbering
- v2.0.0 (2025-11-28) - Added metadata section; updated to 6 agents with correct directories; fixed package path to src/open_agent_kit/
- v1.2.0 (2024-11-13) - Added Section XVI-B: Migration system for upgrade tasks
- v1.1.0 (2025-11-06) - Added Section XVI-A: Complete checklist and patterns for adding new features
- v1.0.0 (2025-11-04) - Initial constitution

---

## XIX. References

- [Python Style Guide (PEP 8)](https://pep8.org/)
- [Semantic Versioning](https://semver.org/)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [GitHub Flow](https://guides.github.com/introduction/flow/)
- [Typer Documentation](https://typer.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [pytest Documentation](https://docs.pytest.org/)

---

**This constitution serves as the definitive guide for open-agent-kit development. All contributors and AI agents should refer to this document for standards, patterns, and practices.**
