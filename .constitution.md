# open-agent-kit Constitution

## Metadata

- **Project:** open-agent-kit
- **Version:** 3.1.0
- **Status:** Adopted
- **Last Updated:** 2025-12-02
- **Author:** @sirkirby
- **Tech Stack:** Python 3.13+, Typer, Pydantic, Rich, Jinja2

**Description:** Open Agent Kit (OAK) is a CLI tool for AI-powered development workflows. It provides agent-agnostic command templates and cli tools to assist and enhance building with AI agents.

This document serves as the central reference for how open-agent-kit is designed, built, and maintained. All agent instruction files reference this constitution.

---

## I. Core Principles

### 1.1 Simplicity First
- Keep the CLI intuitive and easy to use
- Minimize configuration requirements
- Provide sensible defaults
- Make common tasks simple, complex tasks possible

### 1.2 Local-First Design
- No mandatory external dependencies
- Git optional but supported
- Works offline

### 1.3 AI-Assisted Productivity
- Integrate with multiple AI agents
- Templates designed for AI enhancement
- Commands support AI workflows
- Agent-agnostic architecture

### 1.4 Cross-Platform Compatibility
- Support Unix/Linux, macOS, and Windows
- Provide both bash and PowerShell scripts, though CLI commands preferred
- Test on multiple platforms
- Use platform-agnostic Python core

### 1.5 Template-Driven
- All content generated from templates
- Templates are managed by oak (overwritten on upgrade)
- Use Jinja2 for rendering
- Support template inheritance

---

## II. Project Structure

### 2.1 Directory Layout

```bash
open-agent-kit/
├── src/open_agent_kit/               # Source code
│   ├── cli.py             # Main CLI entry point
│   ├── constants.py       # Feature config, validation patterns, decision keys
│   ├── config/            # Configuration modules
│   │   ├── paths.py      # Infrastructure paths (OAK_DIR, CONFIG_FILE, etc.)
│   │   ├── messages.py   # User-facing messages (SUCCESS_MESSAGES, ERROR_MESSAGES)
│   │   └── settings.py   # Runtime settings with env var support (Pydantic Settings)
│   ├── commands/          # CLI command implementations
│   │   ├── init_cmd.py   # oak init
│   │   ├── rfc_cmd.py    # oak rfc commands
│   │   └── feature_cmd.py # oak feature commands
│   ├── models/            # Data models (Pydantic)
│   │   ├── config.py     # Configuration models (OakConfig, RFCConfig, etc.)
│   │   ├── enums.py      # Type-safe enumerations (RFCStatus, PlanStatus, etc.)
│   │   ├── feature.py    # Feature manifest model
│   │   └── rfc.py        # RFC document models
│   ├── services/          # Business logic
│   │   ├── agent_service.py
│   │   ├── config_service.py  # Includes get_*_dir() methods for feature paths
│   │   ├── feature_service.py
│   │   ├── rfc_service.py
│   │   └── template_service.py
│   └── utils/             # Utility functions
│       ├── console.py
│       ├── file_utils.py
│       ├── interactive.py
│       ├── step_tracker.py
│       └── validation.py
├── features/              # Feature packages
│   ├── core/             # Core assets (IDE settings)
│   │   ├── manifest.yaml
│   │   └── ide/
│   ├── constitution/     # Constitution feature
│   │   ├── manifest.yaml
│   │   ├── commands/     # Agent command templates
│   │   └── templates/    # Document templates
│   ├── rfc/              # RFC feature
│   │   ├── manifest.yaml
│   │   ├── commands/
│   │   └── templates/
│   └── issues/           # Issues feature
│       ├── manifest.yaml
│       └── commands/
├── tests/                # Test suite
├── docs/                 # Documentation
├── .github/              # GitHub configuration
│   └── workflows/       # CI/CD workflows
└── pyproject.toml       # Project configuration
```

### 2.2 User Project Structure

After `oak init`, user projects have:

```bash
project/
├── .oak/                     # Configuration directory
│   ├── config.yaml            # Project configuration (includes features.enabled)
│   └── features/             # Feature-specific assets
│       ├── constitution/
│       │   └── templates/    # Constitution templates
│       ├── rfc/
│       │   └── templates/    # RFC templates
│       └── issues/
│           └── templates/    # Issue templates
├── oak/                      # Generated artifacts
│   ├── constitution.md        # Project constitution
│   ├── rfc/                  # RFC documents
│   │   └── RFC-*.md
│   └── issues/                # Issue specifications (spec-driven development)
│       └── {provider}/
│           └── {issue}/
│               ├── context.json
│               └── plan.md
└── .{agent}/commands/        # Agent-specific command files
```

### 2.3 Configuration Hierarchy

1. **Built-in defaults** - Organized across:
   - `config/paths.py` - Infrastructure paths
   - `config/messages.py` - UI messages
   - `config/settings.py` - Runtime settings (with env var support via Pydantic Settings)
   - `constants.py` - Feature config, validation patterns
   - `models/enums.py` - Type-safe status enumerations
2. **Feature manifests** - In `features/<name>/manifest.yaml` (declares `config_defaults.directory`)
3. **Project config** - In `.oak/config.yaml` (feature directories, enabled features, provider settings)
4. **Environment variables** - For API keys and runtime settings (e.g., `OAK_GIT_COMMAND_TIMEOUT_SECONDS`)
5. **Command-line arguments** - Highest priority

`.oak/` is reserved for installation assets (templates, commands, config). All generated work products (RFCs, constitutions, issue specs) live under `oak/` so they can be version-controlled safely.

**Feature directory paths are config-driven:**
- Manifest declares `config_defaults.directory: oak/rfc`
- Init writes to `config.yaml`: `rfc.directory: oak/rfc`
- Services read via `config_service.get_rfc_dir()` (not hardcoded constants)

---

## III. Architecture Patterns

### 3.1 Layered Architecture

```
┌─────────────────────────┐
│   CLI Layer (Typer)     │  ← User interaction
├─────────────────────────┤
│   Command Layer         │  ← Command implementations
├─────────────────────────┤
│   Service Layer         │  ← Business logic
├─────────────────────────┤
│   Model Layer (Pydantic)│  ← Data structures
├─────────────────────────┤
│   Storage Layer         │  ← File system, YAML
└─────────────────────────┘
```

### 3.2 Design Patterns

- **Service Layer Pattern**: Business logic separated from CLI
- **Repository Pattern**: Configuration and data access abstracted
- **Template Method Pattern**: Template rendering with hooks
- **Strategy Pattern**: Multiple agent implementations
- **Factory Pattern**: Agent and template creation

### 3.3 Error Handling

```python
try:
    # Attempt operation
    result = service.operation()
except SpecificError as e:
    # User-friendly error message
    console.error(f"Failed to complete operation: {e}")
    # Provide helpful guidance
    console.info("Try: oak --help")
    sys.exit(1)
```

---

## IV. Code Standards

### 4.1 Python Style

- **PEP 8 compliance**: Use ruff for linting
- **Type hints**: All function signatures must have types
- **Docstrings**: Google-style for all public functions
- **Line length**: 100 characters maximum
- **Formatting**: Use black for consistent formatting

### 4.2 Type Hints

```python
from typing import Optional, List
from pathlib import Path

def create_rfc(
    title: str,
    author: str,
    template: str = "engineering",
    tags: Optional[List[str]] = None
) -> RFCDocument:
    """Create a new RFC document."""
    pass
```

### 4.3 Docstrings

```python
def validate_rfc(file_path: Path, strict: bool = False) -> ValidationResult:
    """Validate an RFC document.

    Args:
        file_path: Path to the RFC file
        strict: Use strict validation rules

    Returns:
        ValidationResult with issues found

    Raises:
        FileNotFoundError: If RFC file doesn't exist
        ValidationError: If RFC format is invalid
    """
    pass
```

### 4.4 Constants and Configuration

**Never use magic strings or numbers.** Literal values are organized by domain:

| Module | Purpose | Example |
|--------|---------|---------|
| `config/paths.py` | Infrastructure paths | `OAK_DIR`, `CONFIG_FILE` |
| `config/messages.py` | UI messages | `SUCCESS_MESSAGES`, `ERROR_MESSAGES` |
| `config/settings.py` | Runtime settings (env vars) | `git_settings.command_timeout_seconds` |
| `models/enums.py` | Type-safe status values | `RFCStatus.DRAFT`, `PlanStatus.READY` |
| `constants.py` | Feature config, patterns | `FEATURE_CONFIG`, `RFC_NUMBER_PATTERN` |

**Bad - Magic Strings:**
```python
if status == "approved":  # Magic string
    process_rfc()

path = Path(".oak/config.yaml")  # Magic string
timeout = 30  # Magic number
```

**Good - Using Organized Constants:**
```python
from open_agent_kit.config.paths import CONFIG_FILE
from open_agent_kit.config.messages import SUCCESS_MESSAGES
from open_agent_kit.config.settings import git_settings
from open_agent_kit.models.enums import RFCStatus

if rfc.status == RFCStatus.APPROVED:
    process_rfc()

path = Path(CONFIG_FILE)
timeout = git_settings.command_timeout_seconds  # Also supports OAK_GIT_COMMAND_TIMEOUT_SECONDS env var
```

**Feature directories are config-driven (not hardcoded):**
```python
# Bad - hardcoded path
rfc_dir = project_root / "oak/rfc"

# Good - read from config
rfc_dir = config_service.get_rfc_dir()  # Reads from config.rfc.directory
```

### 4.5 Error Messages

- Be specific about what went wrong
- Provide actionable guidance
- Use consistent formatting from `ERROR_MESSAGES` constant
- No emojis unless user explicitly requests them

**Good:**
```python
from open_agent_kit.constants import ERROR_MESSAGES

console.error(ERROR_MESSAGES["rfc_not_found"])
console.info("Try: oak rfc list")
```

**Bad:**
```python
console.error("File not found")  # Vague, inconsistent
```

---

## V. CLI Design

### 5.1 Command Structure

```bash
oak [OPTIONS] COMMAND [ARGS]

Commands:
  init        Initialize .oak directory
  rfc         RFC management commands
  version     Show version information
```

### 5.2 Subcommand Pattern

```bash
oak rfc [OPTIONS] SUBCOMMAND [ARGS]

Subcommands:
  create      Create new RFC
  list        List all RFCs
  validate    Validate RFC format
  show        Show RFC details
```

### 5.3 Command usage

User facing commands for oak installation management and configuration:

```bash
# Examples:
oak init [--agent AGENT]
oak upgrade [--dry-run
oak config
```

Agent facing commands referenced in command prompt templates:

```bash
# Examples:
oak rfc create|list|validate
oak constitution create-file|validate|amend
oak issue plan|validate|implement
```

### 5.4 Option Conventions

- Short flags: `-a`, `-v`, `-f`
- Long flags: `--agent`, `--verbose`, `--force`
- Required arguments: `<description>`
- Optional arguments: `[file]`
- Boolean flags: `--no-interactive`, `--force`

### 5.5 Output Design

- Use Rich for formatted output
- Progress indicators for long operations
- Tables for list views
- Panels for detailed information
- Colors for status (green=success, red=error, yellow=warning, blue=info)

### 5.6 Issue Provider Commands (Summary)

- Agents must never run `oak config`; humans handle provider setup interactively.
- Before executing any `oak issue ...` command, verify (in order): constitution exists,
  provider configured, issue ID provided.
- `oak issue plan` scaffolds artifacts, `issue validate` inspects them, and `issue implement`
  prepares the branch for coding—each requires the previous step's outputs.
- Detailed workflows, artifact descriptions, and troubleshooting live in `docs/issue-workflow.md`.

---

## VI. Features System

### 6.1 Feature Architecture

Open Agent Kit uses a modular feature system. Each feature is a self-contained package:

| Feature | Description | Dependencies |
|---------|-------------|--------------|
| **constitution** | Engineering standards, architectural patterns, team conventions | None |
| **rfc** | RFC workflow for documenting technical decisions | constitution |
| **issues** | Issue workflow integration with Azure DevOps/GitHub Issues | constitution |

Core assets (IDE settings) live in `features/core/` and are always installed.

### 6.2 Feature Manifest

Each feature has a `manifest.yaml`:

```yaml
name: my-feature
display_name: "My Feature"
description: "What this feature does"
version: "1.0.0"
default_enabled: true
dependencies: []               # Required features
commands: []                   # Command names (without extension)
templates: []                  # Template paths
config_defaults: {}            # Default config values
```

### 6.3 Dependency Resolution

Features can depend on other features. The `FeatureService` handles:
- Automatic dependency inclusion when installing
- Dependency checking when removing
- Topological sorting for installation order
- Circular dependency detection

### 6.4 Feature CLI Commands

```bash
oak feature              # Interactive feature management
oak feature list         # List installed and available features
oak feature add <name>   # Add a feature (with dependencies)
oak feature remove <name> # Remove a feature (with dependency check)
```

### 6.5 Adding New Features

See `docs/development/features.md` for the complete playbook. Key steps:
1. Create `features/<name>/manifest.yaml`
2. Add command templates in `features/<name>/commands/`
3. Add document templates in `features/<name>/templates/`
4. Update constants (`SUPPORTED_FEATURES`, `FEATURE_CONFIG`)
5. Write tests
6. Update documentation

---

## VII. Template System

### 7.1 Template Type examples

1. **Command Templates** - For AI agent commands (in `features/<feature>/commands/`)
   - `oak.rfc-create.md` - RFC creation assistant
   - `oak.rfc-validate.md` - RFC validation assistant

2. **Document Templates** - For generated documents (in `features/<feature>/templates/`)
   - `engineering.md.j2` - Full technical RFC
   - `constitution.md.j2` - Project constitution

### 7.2 Template Variables

Example use of variables in templates:

```jinja
{{ rfc_number }}       # RFC number (e.g., "001")
{{ title }}            # RFC title
{{ author }}           # Author name
{{ date }}             # Current date (YYYY-MM-DD)
{{ description }}      # RFC description
{{ project_name }}     # Project name
```

---

## VIII. Testing Strategy

### 8.1 Test Types

1. **Unit Tests** - Test individual functions
2. **Integration Tests** - Test command workflows
3. **E2E Tests** - Test full user workflows
4. **Platform Tests** - Test on Ubuntu, Windows, macOS

### 8.2 Test Structure

```bash
tests/
├── unit/
│   ├── test_models.py
│   ├── test_services.py
│   └── test_utils.py
├── integration/
│   ├── test_cli.py
│   └── test_workflows.py
└── conftest.py
```

### 8.3 Coverage Requirements

- Minimum 80% code coverage
- All public APIs tested
- Critical paths fully covered
- Error cases tested

---

## IX. Release Process

### 9.1 Version Numbering

Follow Semantic Versioning (semver):

- **MAJOR.MINOR.PATCH** (e.g., 1.2.3)
- **Pre-releases**: `-beta.1`, `-rc.1`, `-alpha.1`

Increment:
- **MAJOR**: Breaking changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes

### 9.2 Release Checklist

- [ ] Update version in `pyproject.toml`
- [ ] Update version in `src/__init__.py`
- [ ] Update CHANGELOG (if maintained)
- [ ] Run full test suite
- [ ] Run linting and formatting
- [ ] Create git tag
- [ ] Push tag to trigger release workflow

### 9.3 Release Artifacts

Each release includes:
- Python wheel (.whl)
- Source distribution (.tar.gz)
- 12 template packages (6 agents × 2 script types)

---

## X. AI Agent Integration

### 10.1 Supported Agents

| Agent | Description | Instruction File | Command Directory |
|-------|-------------|------------------|-------------------|
| **Claude Code** | Anthropic's AI assistant | `.claude/CLAUDE.md` | `.claude/commands/` |
| **GitHub Copilot** | Microsoft's pair programmer | `.github/copilot-instructions.md` | `.github/agents/` |
| **Codex CLI** | OpenAI's code generation | `AGENTS.md` | `.codex/prompts/` |
| **Cursor** | AI-powered editor | `AGENTS.md` | `.cursor/commands/` |
| **Gemini CLI** | Google's Gemini assistant | `GEMINI.md` | `.gemini/commands/` |
| **Windsurf** | Codeium's AI editor | `.windsurf/rules/rules.md` | `.windsurf/commands/` |

### 10.2 Agent Command Structure

Agent commands are markdown files that guide the AI:

```markdown
# Command Name

Brief description of what this command does.

## Instructions

1. Step 1
2. Step 2
3. Step 3

## Examples

...
```

### 10.3 Adding New Agent Support

To add a new agent:

1. **Add to SUPPORTED_AGENTS** in `constants.py`:
   ```python
   SUPPORTED_AGENTS = ["claude", "copilot", "codex", "cursor", "gemini", "windsurf", "new_agent", "none"]
   ```

2. **Add agent config** to `AGENT_CONFIG` in `constants.py`:
   ```python
   "new_agent": {
       "name": "New Agent",
       "folder": ".new_agent/",
       "commands_subfolder": "commands",
       "file_extension": ".md",
       "requires_cli": False,
       "install_url": None,
   },
   ```

3. **Add instruction file pattern** to `AGENT_INSTRUCTION_PATTERNS` in `constants.py`

4. **Update AgentService** to handle the new agent's command installation

5. **Update documentation** (README, QUICKSTART)

---

## XI. Contributing Guidelines

### 11.1 Code Contributions

1. **Fork repository**
2. **Create feature branch**: `feature/description`
3. **Make changes** with tests
4. **Run checks locally**:
   ```bash
   make check
   make test
   ```
5. **Create pull request**
6. **Address review feedback**
7. **Merge when approved**

### 11.2 Commit Messages

Use conventional commits:

- `Add:` New features
- `Fix:` Bug fixes
- `Update:` Modifications to existing features
- `Docs:` Documentation changes
- `Test:` Test additions/changes
- `Refactor:` Code refactoring

### 11.3 PR Requirements

- All tests pass
- Code coverage maintained
- Documentation updated
- No linting errors
- Type checking passes
- **No magic strings or numbers** (use constants)

---

## XI-A. Configuration Best Practices

### XI-A.1 The No-Magic-Strings Principle

**All literal values must be defined in organized configuration modules.** This is a core principle of open-agent-kit development.

### XI-A.2 Configuration Module Organization

Literals are organized by domain into purpose-specific modules:

| Module | Purpose | Examples |
|--------|---------|----------|
| `config/paths.py` | Infrastructure paths | `OAK_DIR`, `CONFIG_FILE`, `TEMPLATES_DIR` |
| `config/messages.py` | User-facing messages | `SUCCESS_MESSAGES`, `ERROR_MESSAGES` |
| `config/settings.py` | Runtime settings (env vars) | `git_settings.command_timeout_seconds` |
| `models/enums.py` | Type-safe status values | `RFCStatus.DRAFT`, `PlanStatus.READY` |
| `constants.py` | Feature config, patterns | `AGENT_CONFIG`, `RFC_NUMBER_PATTERN` |

### XI-A.3 When to Use Each Module

**`config/paths.py`** - Infrastructure paths only:

```python
# File paths and directory names
OAK_DIR = ".oak"
CONFIG_FILE = ".oak/config.yaml"
TEMPLATES_DIR = "templates"
```

**`config/messages.py`** - All user-facing text:

```python
SUCCESS_MESSAGES = {
    "init": "Successfully initialized open-agent-kit!",
    "rfc_created": "RFC created successfully!",
}

ERROR_MESSAGES = {
    "no_oak_dir": "No .oak directory found. Run 'oak init' first.",
}
```

**`config/settings.py`** - Runtime settings with environment variable support:

```python
from pydantic_settings import BaseSettings

class GitSettings(BaseSettings):
    command_timeout_seconds: int = 30

    class Config:
        env_prefix = "OAK_GIT_"

git_settings = GitSettings()
# Use: git_settings.command_timeout_seconds
# Override: OAK_GIT_COMMAND_TIMEOUT_SECONDS=60
```

**`models/enums.py`** - Type-safe status enumerations:

```python
class RFCStatus(str, Enum):
    DRAFT = "draft"
    REVIEW = "review"
    APPROVED = "approved"

    @classmethod
    def values(cls) -> list[str]:
        return [e.value for e in cls]
```

**`constants.py`** - Feature configuration and patterns:

```python
# Agent configurations
AGENT_CONFIG = {
    "claude": {"name": "Claude Code", "folder": ".claude/"},
}

# Validation patterns
RFC_NUMBER_PATTERN = r"^RFC-\d{3}$"

# Feature configuration
FEATURE_CONFIG = {...}
```

### XI-A.4 Importing Configuration

**Import from the appropriate module:**

```python
# Paths
from open_agent_kit.config.paths import OAK_DIR, CONFIG_FILE

# Messages
from open_agent_kit.config.messages import SUCCESS_MESSAGES, ERROR_MESSAGES

# Runtime settings
from open_agent_kit.config.settings import git_settings

# Enums (type-safe)
from open_agent_kit.models.enums import RFCStatus, PlanStatus

# Feature config and patterns
from open_agent_kit.constants import AGENT_CONFIG, RFC_NUMBER_PATTERN
```

### XI-A.5 Feature Directory Paths

**Feature directories are config-driven, not hardcoded:**

```python
# ❌ Bad - hardcoded path constant
from open_agent_kit.constants import RFC_DIR
rfc_dir = project_root / RFC_DIR

# ✅ Good - read from config.yaml via service
rfc_dir = config_service.get_rfc_dir()
issue_dir = config_service.get_issue_dir()
plan_dir = config_service.get_plan_dir()
```

The pattern: manifest declares `config_defaults.directory`, init writes to config.yaml, services read via ConfigService methods.

### XI-A.6 Type-Safe Enums vs String Lists

**Prefer type-safe enums for status values:**

```python
# ❌ Old pattern - string list
RFC_STATUSES = ["draft", "review", "approved"]
if status in RFC_STATUSES:
    process()

# ✅ New pattern - type-safe enum
from open_agent_kit.models.enums import RFCStatus

if status == RFCStatus.APPROVED:
    process()

# When you need the list of values:
valid_statuses = RFCStatus.values()  # ["draft", "review", "approved"]
```

### XI-A.7 Benefits of Domain-Specific Modules

1. **Clear Intent** - Import path reveals purpose
2. **Reduced Coupling** - Only import what you need
3. **Type Safety** - Enums catch invalid values at type-check time
4. **Env Var Support** - Pydantic Settings for runtime configuration
5. **Maintainability** - Smaller, focused modules
6. **IDE Support** - Better autocomplete by domain

### XI-A.8 Anti-Pattern Examples

**❌ Bad - Magic Strings:**

```python
if status == "approved":
    path = Path(".oak/config.yaml")
    timeout = 30
```

**✅ Good - Using Organized Configuration:**

```python
from open_agent_kit.config.paths import CONFIG_FILE
from open_agent_kit.config.settings import git_settings
from open_agent_kit.models.enums import RFCStatus

if status == RFCStatus.APPROVED:
    path = Path(CONFIG_FILE)
    timeout = git_settings.command_timeout_seconds
```

### XI-A.9 Adding New Configuration

When adding a new value:

1. **Determine the domain** - path, message, setting, enum, or feature config?
2. **Add to the appropriate module** based on the table in XI-A.2
3. **Use descriptive naming** - UPPER_SNAKE_CASE for constants, lowercase for settings
4. **For enums** - add `values()` classmethod for list access
5. **For settings** - use Pydantic Settings with env var prefix

---

## XII. Workflow Automation

### 12.1 PR Validation

Automatic checks on every PR:
- Linting (ruff)
- Formatting (black)
- Type checking (mypy)
- Tests (pytest) - multi-OS, multi-Python
- Template validation (markdownlint)
- Script validation (shellcheck, PSScriptAnalyzer)
- Integration tests

### 12.2 Release Automation

Triggered by version tags:
- Validates version consistency
- Builds Python packages
- Creates template packages
- Runs full test suite
- Creates GitHub release
- Uploads all artifacts

---

## XIII. Security Practices

### 13.1 Dependencies

- Pin major versions only
- Regular dependency updates
- Security scanning (if available)
- No known vulnerabilities

### 13.2 Secrets Management

- Never commit API keys
- Use environment variables
- Document required secrets
- Support multiple secret sources

### 13.3 Input Validation

- Validate all user inputs
- Sanitize file paths
- Prevent injection attacks
- Handle edge cases

---

## XIV. Documentation Standards

### 14.1 README Requirements

Every significant directory should have a README:

```markdown
# Directory Name

Brief description.

## Contents

- File 1: Description
- File 2: Description

## Usage

Examples...
```

### 14.2 Code Documentation

- All public functions have docstrings
- Complex logic has inline comments
- Type hints on all functions
- Examples in docstrings

### 14.3 User Documentation

Located in `docs/`:
- Getting started guides
- Command references
- Architecture docs
- Development guides

---

## XV. Performance Guidelines

### 15.1 Startup Time

- CLI should start in < 500ms
- Lazy import heavy dependencies
- Cache when appropriate

### 15.2 Operation Speed

- RFC creation: < 1 second
- RFC listing: < 2 seconds
- RFC validation: < 1 second

### 15.3 Resource Usage

- Memory: < 100 MB typical
- Disk: < 10 MB templates
- Network: None required

---

## XVI. Maintenance

### 16.1 Regular Tasks

- Weekly: Review open issues
- Monthly: Update dependencies
- Quarterly: Review architecture
- Yearly: Major version planning

### 16.2 Deprecation Policy

- Announce deprecations 1 minor version ahead
- Maintain backward compatibility for 2 minor versions
- Document migration paths
- Provide warnings in deprecated features

### 16.3 Support

- Issue tracking on GitHub
- Documentation in repository
- Team support channels

---

## XVII-A. Feature Delivery Playbook

The exhaustive checklist for adding or extending features now lives in
`docs/development/features.md`. Use that playbook for step-by-step guidance. This
constitution keeps the high-level rules:

- Always update `AgentService.create_default_commands()` and
  `UpgradeService._get_upgradeable_commands()` when new agent commands are introduced.
- Keep all literals in `src/open_agent_kit/constants.py`.
- Ensure every CLI utility command supports `--json` for agent consumption.
- Tests, documentation, and templates must be updated alongside code.

## XVII-B. Migration System for Upgrade Tasks

The full migration playbook now lives in `docs/development/migrations.md`. Key takeaways:

- Migrations run once via `oak upgrade` and are tracked in `.oak/config.yaml`.
- Create one when you must mutate user files/directories or backfill data—*not* for normal
  template or command updates.
- IDs follow `YYYY.MM.DD_name`. Append new migrations to
  `open_agent_kit/services/migrations.py::get_migrations()`.
- Keep every migration idempotent, well-documented, and covered by tests across fresh and
  existing projects.

## XVIII. Amendment Process

This constitution can be amended when needed:

1. **Propose change** - Create issue or PR
2. **Discuss with team** - Review and gather feedback
3. **Update document** - Increment version
4. **Update agent files** - Ensure consistency
5. **Announce changes** - Notify team

**Version History:**

- v3.1.0 (2025-12-02) - Refactored configuration architecture: modular config/ directory (paths, messages, settings), type-safe enums in models/enums.py, config-driven feature directories; updated Sections II.2, IV.4, XI-A
- v3.0.0 (2025-11-28) - Added features system (Section VI); reorganized templates/ to features/ directory; added FeatureService and feature CLI commands; updated section numbering
- v2.0.0 (2025-11-28) - Added metadata section; updated to 6 agents with correct directories; fixed package path to src/open_agent_kit/
- v1.2.0 (2024-11-13) - Added Section XVI-B: Migration system for upgrade tasks
- v1.1.0 (2025-11-06) - Added Section XVI-A: Complete checklist and patterns for adding new features
- v1.0.0 (2025-11-04) - Initial constitution

---

## XIX. References

- [Python Style Guide (PEP 8)](https://pep8.org/)
- [Semantic Versioning](https://semver.org/)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [GitHub Flow](https://guides.github.com/introduction/flow/)
- [Typer Documentation](https://typer.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [pytest Documentation](https://docs.pytest.org/)

---

**This constitution serves as the definitive guide for open-agent-kit development. All contributors and AI agents should refer to this document for standards, patterns, and practices.**
