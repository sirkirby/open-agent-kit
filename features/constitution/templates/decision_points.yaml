# Constitution Decision Points Framework
# This file defines the interactive decision points for constitution creation
# Agents should use this to guide users through key decisions

testing_strategy:
  question: "What testing approach fits your project?"
  description: "Testing strategy affects development speed, confidence, and infrastructure needs"
  options:
    - id: "comprehensive"
      name: "Comprehensive Testing"
      description: "Test-first development with high coverage and multiple test types"
      requirements:
        - "Test-Driven Development (TDD) approach"
        - "80%+ code coverage required"
        - "Unit tests for all functions"
        - "Integration tests for all critical paths"
        - "End-to-end tests for key user flows"
      best_for:
        - "Production systems"
        - "Regulated industries"
        - "Large teams"
        - "High-reliability requirements"
      requires:
        - "E2E test infrastructure"
        - "Testing discipline across team"
        - "More development time"
        - "CI/CD infrastructure"
      
    - id: "balanced"
      name: "Balanced Testing"
      description: "Test-after acceptable with moderate coverage and selective integration tests"
      requirements:
        - "Test-after implementation acceptable"
        - "60-80% code coverage target"
        - "Unit tests required for new code"
        - "Integration tests for critical paths"
        - "E2E tests optional/recommended"
      best_for:
        - "Most production applications"
        - "Medium-sized teams"
        - "Standard reliability needs"
      requires:
        - "Standard testing frameworks"
        - "Basic CI/CD"
      
    - id: "pragmatic"
      name: "Pragmatic Testing"
      description: "Essential tests only, focusing on critical functionality"
      requirements:
        - "Tests for critical functionality"
        - "40-60% coverage acceptable"
        - "Unit tests focused approach"
        - "Integration tests as needed"
        - "E2E tests optional"
      best_for:
        - "Prototypes and MVPs"
        - "Internal tools"
        - "Small teams"
        - "Rapid iteration needs"
      requires:
        - "Minimal infrastructure"
        - "Clear definition of 'critical'"
      
    - id: "custom"
      name: "Custom Testing Strategy"
      description: "Define your own specific requirements"
      prompt: "Describe your testing requirements in detail"
  
  follow_up_questions:
    - condition: "if comprehensive or balanced"
      questions:
        - id: "coverage_target"
          text: "What coverage percentage target? (e.g., 70, 80, 85)"
          type: "integer"
          validation: "between 40 and 100"
        - id: "coverage_strict"
          text: "Should coverage checks block CI/CD merges?"
          type: "boolean"
          help: "yes = strict enforcement, no = advisory only"
    
    - condition: "if comprehensive"
      questions:
        - id: "has_e2e_infrastructure"
          text: "Do you have E2E test infrastructure set up?"
          type: "boolean"
          help: "Examples: Playwright, Cypress, Selenium setup"
        - id: "e2e_planned"
          text: "Are E2E tests planned for the future?"
          type: "boolean"
          condition: "if has_e2e_infrastructure is false"
        - id: "tdd_required"
          text: "Is Test-Driven Development (TDD) required?"
          type: "boolean"
          help: "yes = tests before implementation, no = test-after acceptable"
        - id: "critical_integration_points"
          text: "List critical integration points requiring tests (comma-separated)"
          type: "list"
          help: "Examples: authentication, payment processing, data sync"
          optional: true
    
    - condition: "if balanced"
      questions:
        - id: "critical_integration_points"
          text: "Which integration points require integration tests? (comma-separated)"
          type: "list"
          help: "Examples: authentication, payment processing, external APIs"
          optional: true
    
    - condition: "if pragmatic"
      questions:
        - id: "critical_functionality"
          text: "Define what qualifies as 'critical functionality'"
          type: "text"
          help: "This helps determine what must be tested"
    
    - condition: "always"
      questions:
        - id: "testing_rationale"
          text: "Brief rationale for this testing strategy"
          type: "text"
          help: "Why does this approach fit your project?"

code_review:
  question: "What code review process do you want?"
  description: "Review requirements affect merge speed and code quality"
  options:
    - id: "strict"
      name: "Strict Review Policy"
      description: "All code requires review and approval before merge"
      requirements:
        - "All pull requests MUST be reviewed"
        - "At least 1 approval required before merge"
        - "No direct commits to main/master"
        - "Review checklist must be followed"
        - "No exceptions for urgent fixes"
      best_for:
        - "Production systems"
        - "Regulated environments"
        - "Distributed teams"
      
    - id: "standard"
      name: "Standard Review Policy"
      description: "Reviews required with flexibility for urgent situations"
      requirements:
        - "Pull requests MUST be reviewed"
        - "At least 1 approval required"
        - "Direct commits allowed for urgent hotfixes"
        - "Hotfixes must be reviewed post-merge"
      best_for:
        - "Most production applications"
        - "Teams with on-call rotation"
      
    - id: "flexible"
      name: "Flexible Review Policy"
      description: "Reviews recommended but not strictly enforced"
      requirements:
        - "Code reviews SHOULD be conducted"
        - "Team members MAY merge without approval"
        - "Complex changes SHOULD be reviewed"
        - "Reviews encouraged for knowledge sharing"
      best_for:
        - "Small teams"
        - "Prototypes"
        - "Internal tools"
      
    - id: "custom"
      name: "Custom Review Policy"
      description: "Define your own review requirements"
      prompt: "Describe your code review policy"
  
  follow_up_questions:
    - condition: "if strict or standard"
      questions:
        - id: "num_reviewers"
          text: "How many reviewers required?"
          type: "integer"
          default: 1
          validation: "between 1 and 5"
        - id: "reviewer_qualifications"
          text: "Any specific reviewer qualifications? (optional)"
          type: "text"
          optional: true
          help: "Examples: senior engineer, domain expert"
    
    - condition: "if standard"
      questions:
        - id: "hotfix_definition"
          text: "What qualifies as an urgent hotfix?"
          type: "text"
          help: "When can the review process be bypassed?"

documentation:
  question: "How comprehensive should documentation requirements be?"
  description: "Documentation level affects onboarding and maintainability"
  options:
    - id: "extensive"
      name: "Extensive Documentation"
      description: "Comprehensive documentation for all aspects"
      requirements:
        - "All public APIs MUST be documented"
        - "All modules MUST have docstrings"
        - "Complex algorithms MUST have inline comments"
        - "ADRs MUST be written for architectural decisions"
        - "README MUST be kept current"
        - "CHANGELOG MUST track all releases"
        - "API documentation MUST be generated"
      best_for:
        - "Open source projects"
        - "Large teams"
        - "High turnover environments"
      
    - id: "standard"
      name: "Standard Documentation"
      description: "Documentation for public interfaces and complex logic"
      requirements:
        - "Public APIs MUST have docstrings"
        - "Complex logic MUST have comments"
        - "README MUST include setup instructions"
        - "ADRs SHOULD be written for major decisions"
        - "CHANGELOG SHOULD track releases"
      best_for:
        - "Most projects"
        - "Standard team sizes"
      
    - id: "minimal"
      name: "Minimal Documentation"
      description: "Essential documentation only"
      requirements:
        - "README MUST exist with basic setup"
        - "Critical functions SHOULD have docstrings"
        - "Complex logic SHOULD have comments"
      best_for:
        - "Prototypes"
        - "Small teams with high context"
        - "Internal tools"
      
    - id: "custom"
      name: "Custom Documentation"
      description: "Define your own documentation requirements"
      prompt: "Describe your documentation standards"
  
  follow_up_questions:
    - condition: "if extensive or standard"
      questions:
        - id: "adr_required"
          text: "Are Architecture Decision Records (ADRs) required?"
          type: "boolean"
        - id: "docstring_style"
          text: "Preferred docstring style? (google/numpy/sphinx)"
          type: "choice"
          options: ["google", "numpy", "sphinx", "other"]
          default: "google"

architectural_patterns:
  question: "What architectural patterns and principles guide your codebase?"
  description: "Architectural patterns define how code is organized and how components interact"
  options:
    - id: "vertical_slice"
      name: "Vertical Slice Architecture"
      description: "Organize code by features/use-cases rather than technical layers"
      characteristics:
        - "Features are self-contained vertical slices"
        - "Each slice contains all layers needed (UI, business logic, data access)"
        - "Minimal coupling between slices"
        - "Easy to understand feature scope"
      best_for:
        - "Feature-driven development"
        - "Teams organized by product areas"
        - "Rapid feature iteration"
        - "Microservices preparation"
      patterns:
        - "Feature folders (e.g., features/user-registration/)"
        - "Command/Query separation (CQRS-lite)"
        - "Mediator pattern for feature orchestration"
      
    - id: "clean_architecture"
      name: "Clean Architecture (Onion/Hexagonal)"
      description: "Layer code with dependency inversion, business logic at the center"
      characteristics:
        - "Core business logic has no external dependencies"
        - "Dependencies point inward toward domain"
        - "Ports & Adapters for external integrations"
        - "Testable business rules in isolation"
      best_for:
        - "Complex business domains"
        - "Long-lived applications"
        - "Multiple UI or integration points"
        - "High testability requirements"
      patterns:
        - "Domain entities and value objects"
        - "Repository pattern"
        - "Use cases / Application services"
        - "Dependency injection"
      
    - id: "layered"
      name: "Traditional Layered Architecture"
      description: "Organize by technical layers (presentation, business, data)"
      characteristics:
        - "Horizontal separation by technical concern"
        - "Presentation → Business → Data access"
        - "Each layer depends on layer below"
        - "Clear separation of technical responsibilities"
      best_for:
        - "Traditional enterprise applications"
        - "Teams organized by technical specialty"
        - "Well-understood problem domains"
        - "CRUD-heavy applications"
      patterns:
        - "Controllers, Services, Repositories"
        - "DTOs for layer boundaries"
        - "Transaction script pattern"
      
    - id: "modular_monolith"
      name: "Modular Monolith"
      description: "Single deployment with strong module boundaries"
      characteristics:
        - "Modules are independently developable"
        - "Clear module interfaces and contracts"
        - "Shared database but isolated schemas/tables"
        - "Eventual microservices extraction path"
      best_for:
        - "Teams wanting microservices benefits without complexity"
        - "Growing applications"
        - "Cost-conscious deployments"
      patterns:
        - "Module boundaries with public APIs"
        - "Domain events for module communication"
        - "Shared kernel for cross-cutting concerns"
      
    - id: "pragmatic"
      name: "Pragmatic / Adaptive"
      description: "Mix patterns based on context, no single architecture"
      characteristics:
        - "Use patterns where they add value"
        - "Simple code for simple features"
        - "Sophisticated patterns for complex domains"
        - "Architecture emerges from needs"
      best_for:
        - "Small to medium projects"
        - "Rapid prototyping"
        - "Teams with diverse experience"
      
    - id: "custom"
      name: "Custom Architecture"
      description: "Define your own architectural approach"
      prompt: "Describe your architectural patterns and principles"
  
  follow_up_questions:
    - condition: "if vertical_slice or clean_architecture or modular_monolith"
      questions:
        - id: "error_handling_pattern"
          text: "What error/result handling pattern do you use?"
          type: "choice"
          options:
            - value: "result_pattern"
              label: "Result Pattern (Result<T, Error>)"
              description: "Explicit success/failure types, no exceptions for expected errors"
            - value: "exceptions"
              label: "Exception-based"
              description: "Use exceptions for all error handling"
            - value: "mixed"
              label: "Mixed approach"
              description: "Result pattern for domain, exceptions for infrastructure"
            - value: "other"
              label: "Other pattern"
          help: "How do you represent and propagate errors?"
        
        - id: "dependency_injection"
          text: "Is dependency injection required?"
          type: "boolean"
          help: "DI is typical for Clean Architecture and testability"
        
        - id: "domain_events"
          text: "Do you use domain events for decoupling?"
          type: "boolean"
          help: "Domain events enable loose coupling between modules/slices"
    
    - condition: "if vertical_slice or modular_monolith"
      questions:
        - id: "feature_organization"
          text: "How are features/modules organized?"
          type: "text"
          help: "Example: 'features/{feature-name}/' or 'modules/{module-name}/'"
          placeholder: "features/{feature-name}/"
    
    - condition: "if clean_architecture or layered"
      questions:
        - id: "layer_organization"
          text: "What are your primary layers?"
          type: "text"
          help: "Example: 'domain, application, infrastructure, presentation'"
          placeholder: "domain, application, infrastructure, presentation"
    
    - condition: "always"
      questions:
        - id: "coding_principles"
          text: "Key coding principles? (comma-separated)"
          type: "list"
          help: "Examples: SOLID, DRY, YAGNI, KISS"
          optional: true
        
        - id: "architectural_rationale"
          text: "Why does this architecture fit your project?"
          type: "text"
          help: "Brief explanation of the architectural choice"

ci_cd:
  question: "What CI/CD checks should be enforced?"
  description: "CI/CD enforcement affects merge speed and quality gates"
  options:
    - id: "full"
      name: "Full Enforcement"
      description: "Comprehensive checks that block merges"
      requirements:
        - "Linting MUST pass"
        - "Type checking MUST pass"
        - "All tests MUST pass"
        - "Security scans MUST pass"
        - "Coverage requirements MUST be met"
        - "All checks MUST pass before merge"
      best_for:
        - "Production systems"
        - "Mature projects"
        - "Large teams"
      
    - id: "standard"
      name: "Standard Enforcement"
      description: "Core checks that block merges"
      requirements:
        - "Linting MUST pass"
        - "Tests MUST pass"
        - "Coverage checks (if enabled) MUST pass"
        - "Type checking SHOULD pass"
        - "Core checks MUST pass before merge"
      best_for:
        - "Most projects"
        - "Growing codebases"
      
    - id: "basic"
      name: "Basic Enforcement"
      description: "Essential checks, advisory only"
      requirements:
        - "Tests SHOULD pass"
        - "Linting results displayed but non-blocking"
        - "Checks are advisory"
      best_for:
        - "Early-stage projects"
        - "Small teams"
        - "Rapid iteration"
      
    - id: "none"
      name: "No CI/CD Yet"
      description: "Planning phase, no enforcement"
      requirements:
        - "CI/CD to be implemented"
      best_for:
        - "New projects"
        - "Pre-CI phase"
      
    - id: "custom"
      name: "Custom CI/CD"
      description: "Define your own CI/CD requirements"
      prompt: "Describe your CI/CD checks"
  
  follow_up_questions:
    - condition: "if full or standard"
      questions:
        - id: "required_checks"
          text: "Which checks are required? (comma-separated)"
          type: "list"
          default: "tests,linting"
          help: "Options: tests, linting, type-checking, security, coverage"
        - id: "ci_platform"
          text: "CI/CD platform? (optional)"
          type: "text"
          optional: true
          help: "Examples: GitHub Actions, GitLab CI, CircleCI"
    
    - condition: "if none"
      questions:
        - id: "ci_planned"
          text: "Is CI/CD implementation planned?"
          type: "boolean"
        - id: "ci_timeline"
          text: "When is CI/CD planned? (optional)"
          type: "text"
          optional: true
          condition: "if ci_planned is true"

# Decision confirmation template
confirmation_template: |
  === Constitution Decision Summary ===
  
  Based on our conversation, here's what will be in your constitution:
  
  ## Testing Strategy: {testing_strategy}
  {testing_details}
  
  ## Code Review: {code_review_policy}
  {code_review_details}
  
  ## Documentation: {documentation_level}
  {documentation_details}
  
  ## CI/CD: {ci_enforcement}
  {ci_cd_details}
  
  ---
  
  This will result in:
  - {must_count} MUST requirements (mandatory)
  - {should_count} SHOULD recommendations (encouraged)
  - {may_count} MAY options (flexible)
  
  Rationale: {overall_rationale}
  
  Do these decisions accurately reflect your project needs?
  - yes: Proceed with constitution generation
  - no: Cancel and restart
  - revise: Modify specific decisions

